-- arithmeticInterpreter.byr

--With                    -- To compile in Ada
--Ada.Text_IO;            -- To compile in Ada

procedure main is

   --Use Ada.Text_IO;     -- To compile in Ada

   procedure Expresion(c: in out Character; resultado: out Integer);

   procedure Error is
   begin   

      Put("Expresion erronea. Last car: ");

   end Error;


   procedure Numero(c: in out Character; resultado: out Integer) is
   begin

      resultado := 0;
      
      if (c < '0' or c > '9') then
        Error();       
        Put("Numero: '"); 
        Put(c); 
        Put("'\n");
      end if;

      while (c > '0' and c < '9') loop
         resultado := 10*resultado + c - '0' ;                            -- Byron style, explicit casting.
         --Put(resultado);
         Get (c);
      end loop; 

      --Put("Numero acaba: '"); 
      --Put(c);
      --Put("'\n");

   end Numero;

   procedure Factor(c: in out Character; resultado: out Integer) is
   begin

    --resultado := 0;
      
    if (c = '(') then

      --Put("aa");

      Get (c);
       
      --Put("Llama Expresion: '"); 
 			--Put(c);
			--Put("'\n");

      Expresion(c,resultado);

      --Put("Vuelve Expresion: '"); 
 			--Put(c);
			--Put("'\n");

       
      if (c = ')') then
        Get (c);
      else
        --Put("1");
        Error();
        Put("Factor: '"); 
        Put(c); 
        Put("'\n");
      end if;
       
    else
      Numero(c, resultado);   
    end if;

    --Put("Factor acaba: '"); 
 		--Put(c);
		--Put("'\n");

  end Factor;

  procedure Termino(c: in out Character; resultado: out Integer) is
    op : Character;
    aux : Integer;
  begin
  	--Put("Llama Factor: '"); 
  	--Put(c);
		--Put("'\n");

    Factor(c, resultado);
    
    --Put("Vuelve Factor: '"); 
 		--Put(c);
		--Put("'\n");

    while (c = '*' or c = '/') loop

      op:=c;
      Get(c);

      --Put("Llama Factor2: '"); 
  	  --Put(c);
	  	--Put("'\n");

      Factor(c, aux);

      --Put("Vuelve Factor2: '"); 
 			--Put(c);
			--Put("'\n");
      

      if(op = '*') then
        resultado := resultado*aux;
      end if;
      if(op = '/') then
        resultado := resultado/aux;
      end if;
      null;
    end loop;
    null;
          
    --Put("Sale Factor: '"); 
 		--Put(c);
		--Put("'\n");        
  end Termino; 

  procedure Expresion(c: in out Character; resultado: out Integer) is 
    op : Character;
    aux : Integer;
  begin
     
    if(c='+' or c='-')then
       op := c;
       Get(c);
    end if;
    
    --Put("Entra Termino: '"); 
 		--Put(c);
		--Put("'\n");

    Termino(c, resultado);

    --Put("Sale Termino: '"); 
 		--Put(c);
		--Put("'\n");
      
    if (op = '-') then
      resultado := -resultado;
    end if;
      
    while (c = '+' or c = '-') loop
      op:=c;

      Get(c);

      --Put("Entra Termino2: '"); 
 			--Put(c);
			--Put("'\n");

      Termino(c, aux);

      --Put("vuelve Termino2: '"); 
 			--Put(c);
			--Put("'\n");

    

      if(op = '+') then
        resultado := resultado+aux;
      end if;
      if(op = '-') then
        resultado := resultado-aux;
      end if;

    end loop;

    --Put("Sale Expresion: '"); 
 		--Put(c);
		--Put("'\n");

            
  end Expresion;
      
  n : Character;    
  c : Character;
  resultado : Integer;

begin
  c:='y';
  -- Due to limitations of get in Ada, the expression has to finish with ;
   
  while (c /= 'n') loop
    Put("Put your expression: ");
    Get(c);

    Expresion(c, resultado);

    --Get(n); --Avoid \n

    --Put("'");  
    --Put(c);
      
    --Put("' Result is: "); 
    Put("Result is: ");

    Put(resultado);  -- Byron style, implicit casting to literal_string
    New_Line;
      
    Put("New expression?(y/n): ");
    Get(c);
    Get(n); --Ignore until ;
    while(n /= ';') loop
    	Get(n);
    end loop;
    Get(n); --Read \n

  end loop;
    
  null;

end main;